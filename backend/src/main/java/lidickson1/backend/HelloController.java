package lidickson1.backend;

import me.xdrop.fuzzywuzzy.FuzzySearch;
import org.apache.tomcat.util.json.JSONParser;
import org.apache.tomcat.util.json.ParseException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.util.Pair;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@CrossOrigin(origins = "http://localhost:4200")
public class HelloController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private CompanyRepository companyRepository;
    @Autowired
    private ApplicationRepository applicationRepository;

    @GetMapping("/")
    public String index() {
        return "Greetings from Spring Boot!";
    }

    @GetMapping("/companies")
    public @ResponseBody Iterable<Company> getAllCompanies() {
        return this.companyRepository.findAll();
    }

    @PostMapping("/company/add")
    public @ResponseBody Company addCompany(@RequestBody Company company) {
        return this.companyRepository.save(company);
    }

    @GetMapping("/applications")
    public @ResponseBody Iterable<Application> getAllApplications(@RequestParam(required = false) Integer page) {
        if (page != null) {
            return this.applicationRepository.findAll(PageRequest.of(page, 10, Sort.by("appliedDate").descending()));
        } else {
            return this.applicationRepository.findAll();
        }
    }

    @GetMapping("/applications-company")
    public @ResponseBody Iterable<Application> getApplicationsByCompany(@RequestParam String company) {
        //convert iterator to list
        List<Pair<Application, Integer>> applications = new ArrayList<>();
        this.applicationRepository.findAll().forEach(application -> applications.add(
                Pair.of(application, FuzzySearch.ratio(this.companyRepository.findById(application.company).get().name, company))
        ));
        applications.sort((a, b) -> Integer.compare(b.getSecond(), a.getSecond()));
        //only accept fuzzy ratio >= 10%, and get the top 10
        return applications.stream().filter(pair -> pair.getSecond() >= 10).map(Pair::getFirst).limit(10).collect(Collectors.toList());
    }

    @GetMapping("/applications/total")
    public @ResponseBody long getNumOfApplications() {
        return this.applicationRepository.count();
    }

    @PostMapping("/application/add")
    public @ResponseBody Application addApplication(@RequestBody String body) {
        try {
            LinkedHashMap<String, Object> json = new JSONParser(body).object();
            Optional<Company> companyOptional = this.companyRepository.findByName(json.get("company").toString()).stream().findFirst();
            Company company;
            if (companyOptional.isPresent()) {
                company = companyOptional.get();
            } else {
                company = new Company();
                company.name = json.get("company").toString();
                company.image = json.get("image").toString();
                company = this.companyRepository.save(company); //because we need to auto-generated id
            }
            Application application = new Application();
            application.company = company.id;
            application.position = json.get("position").toString();
            if (json.get("location") != null) {
                application.location = json.get("location").toString();
            }
            if (json.get("job_type") != null) {
                application.job_type = json.get("job_type").toString();
            }
            application.status = "applied";
            application.appliedDate = Timestamp.from(Instant.parse(json.get("applied_date").toString()));
            return this.applicationRepository.save(application);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }
    }

    record Reject(int id, String timestamp) {}
    @PostMapping("/application/reject")
    public @ResponseBody Application rejectApplication(@RequestBody Reject reject) {
        var optional = this.applicationRepository.findById(reject.id);
        if (optional.isPresent()) {
            Application application = optional.get();
            application.status = "rejected";
            application.rejectedDate = Timestamp.from(Instant.parse(reject.timestamp));
            return this.applicationRepository.save(application);
        } else {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
    }
}